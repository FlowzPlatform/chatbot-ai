'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debugLevels = require('debug-levels');

var _debugLevels2 = _interopRequireDefault(_debugLevels);

var _botLang = require('bot-lang');

var _botLang2 = _interopRequireDefault(_botLang);

var _requireDir = require('require-dir');

var _requireDir2 = _interopRequireDefault(_requireDir);

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debugLevels2.default)('SS:Message');

const plugins = {};

// To load user plugins, just run Message.loadPlugins
const loadPlugins = function loadPlugins(path) {
  try {
    const pluginFiles = (0, _requireDir2.default)(path);
    Object.keys(pluginFiles).forEach(file => {
      // For transpiled ES6 plugins with default export
      if (pluginFiles[file].default) {
        pluginFiles[file] = pluginFiles[file].default;
      }

      Object.keys(pluginFiles[file]).forEach(func => {
        debug.verbose('Loading plugin:', path, func);
        plugins[func] = pluginFiles[file][func];
      });
    });
  } catch (e) {
    console.error(`Could not load plugins from ${path}: ${e}`);
  }
};

// Load built-in plugins
loadPlugins(`${__dirname}/plugins`);

class Message {
  /**
   * Creates a new Message object.
   * @param {String} message - The cleaned message.
   * @param {Object} options - The parameters.
   * @param {Object} options.factSystem - The fact system to use.
   * @param {Object} options.scope - Any additional per-message scope to pass in.
   */
  constructor(message, options, callback) {
    debug.verbose(`Creating message from string: ${message}`);

    this.id = _util2.default.genId();
    // this.plugins = options.plugins || {};

    this.factSystem = options.factSystem;
    this.createdAt = new Date();

    /**
     * We have a series of transforms that are applied to the input
     * `original` is the message `EXACTLY AS WRITTEN` by the user
     *
     * `raw` leans on bot-land and expands contractions, and fixes spelling
     *       - We also remove frivilous words, and convert to us-english.
     *
     * `clean` has been stripped of all punctuation and left with a word token form.
     */
    this.original = message;
    this.raw = _botLang2.default.replace.all(message).trim();
    this.clean = _util2.default.cleanMessage(this.raw).trim();

    debug.verbose('Message before cleaning: ', message);
    debug.verbose('Message RAW: ', this.raw);
    debug.verbose('Message CLEAN: ', this.clean);

    const scope = _lodash2.default.merge({}, options.scope);
    scope.message = this;

    const eachPluginItor = (functionName, next) => {
      const functionArgs = [];
      functionArgs.push(err => next(err));
      functionName.apply(scope, functionArgs);
    };

    _async2.default.each(plugins, eachPluginItor, () => {
      callback(null, this);
    });
  }
}

const createMessage = function createMessage(message, options, callback) {
  if (!message) {
    debug.verbose('Message received was empty, callback immediately');
    return callback(null, {});
  }

  return new Message(message, options, callback);
};

exports.default = {
  createMessage,
  loadPlugins
};